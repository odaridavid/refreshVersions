{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Gradle refreshVersions \u00b6 Life is too short to google for dependencies and versions Why refreshVersions? \u00b6 Gradle multi-module projects are on the rise. At the same time, library vendors publish very modularized artifacts: - On Android, the big fat support libraries are dead, and their replacement, AndroidX , contains more than 200 different dependencies, grouped in over 70 groups, each having its own version. (AndroidX is only a part of first-party dependencies for Android projects, and third party dependencies can add up.) - On the server, many frameworks or library suites offer a high number of artifacts. That applies to Ktor, Spring, http4k and others. Again, that\u2019s not even counting third party dependencies. Both trends come with great technical benefits. However, they also make it much more tedious to find where to add and update your dependencies in all those build.gradle[.kts] files! We saw this make developers update the dependencies less and less often, effectively leading to legacy accumulation (a form of technical debt), or even projects abandon. Yes, that\u2019s sad. Can we have our cake and eat it? We firmly believe that yes, we can have the benefits of modularization without the hell of dependency management . So what does gradle refreshVersions ? Centralize your dependencies in a proper file format \u00b6 Everyone who uses Gradle in a multi-modules environment has looked for a way to centralize all dependencies in one place. And there are solutions for that. Too many solutions in fact. Some put their versions in a variable val retrofitVersion = 2.9.0 , others in rootproject.ext , others in a libraries.gradle file, others still in buildSrc/src/main/Versions.kt , and the list goes on and on! A problem common to all those solutions is that they store the versions in a turing-complete programming language (Groovy or Kotlin). Then people try to hack together regular expressions to read or modify those files. We think this is wrong! Instead, gradle refreshVersions stores all the versions in one place in a proper file format: Java Properties, like gradle.properties . Just like npm\u2019s package.json , Maven\u2019s pom.xml , this file can be easily read and written by a computer program. Yes to better tooling! No Magic! \u00b6 You wonder how this works? No black magic involved, we leverage Gradle public APIs that are designed to edit declared dependencies ( Configuration.withDependencies , and PluginManagement.resolutionStrategy ), and we edit the versions constraints there. The rest is just a set of conventions. Consider the example below: Dependency notation Version key org.gradle:gradle-hello-world-plugin:_ version.org.gradle..gradle-hello-world-plugin com.squareup.retrofit2:retrofit:_ version.retrofit com.squareup.retrofit2:retrofit-adapter-xxx:_ version.retrofit plugin with id \u201ccom.squareup.sqldelight\u201d plugin.com.squareup.sqldelight gradle refreshVersions works with an opt-in mechanism. It only manages dependencies where the version is set to be a placeholder, more specifically the underscore _ , which, akin to Kotlin, here means that the version is not used, being instead set in the versions.properties file. gradle refreshVersions has a system of rules that here, allows to set all Retrofit dependencies with the same version key version.retrofit , keeping things DRY. Look up for updates automatically \u00b6 With this infrastructure being in place, the major feature of gradle refreshVersions is like its name suggests: It will look up for all available updates of the dependencies used in the project. Simply run $ ./gradlew refreshVersions and you will see the available updates as comments : Why as comment? Because while googling manually for available updates is a monkey job that is best done by a computer program, while deciding whether to upgrade or not is your job as a programmer. Read more: Update Dependencies It\u2019s fast! \u00b6 The Kotlin Libraries Playground contains about 80 dependencies, and counting. How long would it take to search for all available updates? Well, if you do it manually: enough to hate your life . With the gradle-versions-plugin it will take about 2 minutes. With refreshVersions, you are done in 10 seconds ! See benchmarks here. Add dependencies quickly! \u00b6 gradle refreshVersions provides read-to-use organized dependency notations for popular libraries. Read more: Add Dependencies Requirements \u00b6 Gradle 6.3+ IntelliJ IDEA or Android Studio Try it out with zero setup! \u00b6 The simplest way to try out gradle refreshVersions is with our official sample, the Kotlin libraries Playground ! Everything is pre-configured here, so just open the project in IntelliJ and start adding and upgrading dependencies. Warning: You may also learn a ton of things about Kotlin libraries in the process! Funding \u2764\ufe0f \u00b6 We hope this open source project saves you a lot of time! It is maintained by its authors, Jean-Michel Fayard and Louis CAD. You can buy us more time by becoming our sponsors: \ud83d\udc9d Louis CAD GitHub Sponsors page \ud83d\udc9d Jean-Michel GitHub Sponsors page We\u2019re very grateful to you and our existing sponsors , thank you! \u2764\ufe0f\u2764\ufe0f Contributing \u00b6 This project is under the MIT License. Explain your use case and start the discussion before your submit a pull-request CONTRIBUTING describes the process for submitting pull requests.","title":"Overview"},{"location":"#gradle-refreshversions","text":"Life is too short to google for dependencies and versions","title":"Gradle refreshVersions"},{"location":"#why-refreshversions","text":"Gradle multi-module projects are on the rise. At the same time, library vendors publish very modularized artifacts: - On Android, the big fat support libraries are dead, and their replacement, AndroidX , contains more than 200 different dependencies, grouped in over 70 groups, each having its own version. (AndroidX is only a part of first-party dependencies for Android projects, and third party dependencies can add up.) - On the server, many frameworks or library suites offer a high number of artifacts. That applies to Ktor, Spring, http4k and others. Again, that\u2019s not even counting third party dependencies. Both trends come with great technical benefits. However, they also make it much more tedious to find where to add and update your dependencies in all those build.gradle[.kts] files! We saw this make developers update the dependencies less and less often, effectively leading to legacy accumulation (a form of technical debt), or even projects abandon. Yes, that\u2019s sad. Can we have our cake and eat it? We firmly believe that yes, we can have the benefits of modularization without the hell of dependency management . So what does gradle refreshVersions ?","title":"Why refreshVersions?"},{"location":"#centralize-your-dependencies-in-a-proper-file-format","text":"Everyone who uses Gradle in a multi-modules environment has looked for a way to centralize all dependencies in one place. And there are solutions for that. Too many solutions in fact. Some put their versions in a variable val retrofitVersion = 2.9.0 , others in rootproject.ext , others in a libraries.gradle file, others still in buildSrc/src/main/Versions.kt , and the list goes on and on! A problem common to all those solutions is that they store the versions in a turing-complete programming language (Groovy or Kotlin). Then people try to hack together regular expressions to read or modify those files. We think this is wrong! Instead, gradle refreshVersions stores all the versions in one place in a proper file format: Java Properties, like gradle.properties . Just like npm\u2019s package.json , Maven\u2019s pom.xml , this file can be easily read and written by a computer program. Yes to better tooling!","title":"Centralize your dependencies in a proper file format"},{"location":"#no-magic","text":"You wonder how this works? No black magic involved, we leverage Gradle public APIs that are designed to edit declared dependencies ( Configuration.withDependencies , and PluginManagement.resolutionStrategy ), and we edit the versions constraints there. The rest is just a set of conventions. Consider the example below: Dependency notation Version key org.gradle:gradle-hello-world-plugin:_ version.org.gradle..gradle-hello-world-plugin com.squareup.retrofit2:retrofit:_ version.retrofit com.squareup.retrofit2:retrofit-adapter-xxx:_ version.retrofit plugin with id \u201ccom.squareup.sqldelight\u201d plugin.com.squareup.sqldelight gradle refreshVersions works with an opt-in mechanism. It only manages dependencies where the version is set to be a placeholder, more specifically the underscore _ , which, akin to Kotlin, here means that the version is not used, being instead set in the versions.properties file. gradle refreshVersions has a system of rules that here, allows to set all Retrofit dependencies with the same version key version.retrofit , keeping things DRY.","title":"No Magic!"},{"location":"#look-up-for-updates-automatically","text":"With this infrastructure being in place, the major feature of gradle refreshVersions is like its name suggests: It will look up for all available updates of the dependencies used in the project. Simply run $ ./gradlew refreshVersions and you will see the available updates as comments : Why as comment? Because while googling manually for available updates is a monkey job that is best done by a computer program, while deciding whether to upgrade or not is your job as a programmer. Read more: Update Dependencies","title":"Look up for updates automatically"},{"location":"#its-fast","text":"The Kotlin Libraries Playground contains about 80 dependencies, and counting. How long would it take to search for all available updates? Well, if you do it manually: enough to hate your life . With the gradle-versions-plugin it will take about 2 minutes. With refreshVersions, you are done in 10 seconds ! See benchmarks here.","title":"It's fast!"},{"location":"#add-dependencies-quickly","text":"gradle refreshVersions provides read-to-use organized dependency notations for popular libraries. Read more: Add Dependencies","title":"Add dependencies quickly!"},{"location":"#requirements","text":"Gradle 6.3+ IntelliJ IDEA or Android Studio","title":"Requirements"},{"location":"#try-it-out-with-zero-setup","text":"The simplest way to try out gradle refreshVersions is with our official sample, the Kotlin libraries Playground ! Everything is pre-configured here, so just open the project in IntelliJ and start adding and upgrading dependencies. Warning: You may also learn a ton of things about Kotlin libraries in the process!","title":"Try it out with zero setup!"},{"location":"#funding","text":"We hope this open source project saves you a lot of time! It is maintained by its authors, Jean-Michel Fayard and Louis CAD. You can buy us more time by becoming our sponsors: \ud83d\udc9d Louis CAD GitHub Sponsors page \ud83d\udc9d Jean-Michel GitHub Sponsors page We\u2019re very grateful to you and our existing sponsors , thank you! \u2764\ufe0f\u2764\ufe0f","title":"Funding \u2764\ufe0f"},{"location":"#contributing","text":"This project is under the MIT License. Explain your use case and start the discussion before your submit a pull-request CONTRIBUTING describes the process for submitting pull requests.","title":"Contributing"},{"location":"CHANGELOG/","text":"Change log for refreshVersions \u00b6 Unreleased \u00b6 TK (Also, screw GitHub Actions, their workflow_dispatch doesn\u2019t work.) Version 0.9.7 (2020-10-16) \u00b6 Fixes \u00b6 Running the refreshVersions task twice or more would fail with \u201cexecutor rejected\u201d as an error message, until the Gradle daemon is killed. This has now been fixed. (Issue #263) The refreshVersions task was failing after the latest Gradle release candidate was superseded by the stable release because the API would return an empty JSON object after this, which we didn\u2019t expect. (Minor) We fixed a typo in a diagnostic task name ( refreshVersionsDependenciesMapping ) Version 0.9.6 (2020-10-12) \u00b6 Fixes \u00b6 This release fixes a major memory leak that would make Gradle Daemons unusable after several builds (or Gradle syncs/imports). We are very sorry for that issue, and the annoyance it might have caused. We experienced it too as users, and that\u2019s why we are bringing the fix now. We took the necessary measures to avoid future recurrence of such memory leaks. Fix of a bug that\u2019d make the first Gradle sync after adding a dependency fail. Breaking change \u00b6 If you were using Jetpack Compose, the compiler dependency had its maven coordinates changed in version 1.0.0-alpha04. We updated the AndroidX.compose.compiler dependency constant, which means it now works only for Compose 1.0.0-alpha04 and more future versions. New dependency constants \u00b6 Google.android.playServices.mlKit Google.mlKit KotlinX.serialization.json Deprecated \u00b6 Firebase ML Kit has been rebranded to Google ML Kit along with API and feature changes since 2020-08-14 update , so we deprecated the Firebase.mlKit dependencies and introduced new ones in Google.android.playServices.mlKit and Google.mlKit . New features \u00b6 refreshVersions will now warn you when Gradle is not up to date, and will give you the commands to run to update it for you to copy/paste and run. It works if you\u2019re using a release candidate, and also if you\u2019re using a nightly version! Version 0.9.5 (2020-08-21) \u00b6 This is a major release that brings surface-level and internal changes, paving the way for the upcoming 1.0 release. The plugin setup/bootstrap has changed , so check out the updated documentation in Setup . New features \u00b6 Self update discovery. RefreshVersions will check for its own updates , and add available comments in the settings.gradle[.kts] file if needed for easy upgrade. This allows you to get future improvements conveniently. Support for buildscript dependencies. It now works just like regular dependencies. First class support for buildSrc Support maven repositories with basic authentication (aka. credentials with username and password) Going forward, refreshVersions will be able to auto-migrate any breaking changes a new version would introduce in your versions.properties , build.gradle and build.gradle.kts files in. This version of refreshVersions integrates the facility to let future versions of refreshVersions that migration is needed, and from which version. This is a very important change that ensures you can keep your projects updated with the least effort possible. New dependency constants \u00b6 Kotlin.stdlib (for the base version of the stdlib) KotlinX: html Coroutines: reactive reactor rx2 rx3 Serialization: core (replaces runtime artifacts since 1.0.0-RC) protobuf cbor properties io reflect.lite nodeJs COIL , a **Co**routine **I**mage **L**oader for Android. Square: LeakCanary KotlinPoet Wire SqlDelight Moshi Picasso okio Retrofit2: Adapter: java8 (renamed from retrofitJava8) rxJava1 (renamed from retrofitRxJava1) rxJava2 (renamed from retrofitRxJava2) rxJava3 KoTest (in the Testing object) CashApp: sqlDelight (alias to Square.sqlDelight) turbine Copper Google: Dagger (including hilt for Android) Android: browserHelper JakeWharton: picnic wormholeGradlePlugin confundusGradlePlugin moshi.shimo AndroidX: Gaming Hilt startup tracing vectorDrawableSeekable Window Core: animation animationTesting Security: cryptoKtx identityCredential Compose: Runtime: dispatch savedInstance liveData rxJava2 Animation Ui Foundation Material Media2: lifecycle Concurrent: futuresKtx Dependency constants renamed \u00b6 Several dependencies constants have been renamed in this release (compared to version 0.9.4). If you were using one of the following, you\u2019ll need to migrate these usages. We recommend to use \u201cReplace in Path\u201d in IntelliJ or Android Studio, filtering for the *.gradle.kts or *.gradle file extensions to do these replacements with ease. Note that for future versions, refreshVersions will be able to do this automatically. Here\u2019s the list of renamed dependency constants: AndroidX.coreKtx -> AndroidX.core.ktx AndroidX.coreRole -> AndroidX.core.role Square.retrofit2.adapter.retrofitJava8 -> Square.retrofit2.adapter.java8 Square.retrofit2.adapter.retrofitRxJava1 -> Square.retrofit2.adapter.rxJava1 Square.retrofit2.adapter.retrofitRxJava2 -> Square.retrofit2.adapter.rxJava2 Testing.junit.junitJupiter -> Testing.junit Testing.mockK.mockK -> Testing.mockK Changes \u00b6 Make the refreshVersions task cancellable during network requests. Now, only http 404 and 401 responses from repositories will be silent. Server errors (i.e. all but http 404 and 401 responses) are now reported. Network failures are now reported. There is now a connection timeout (10 seconds per request for now) An error is reported if a dependency wasn\u2019t found in any of the configured repositories. All the searched repositories are now listed if a dependency wasn\u2019t found in any of them. Only declared repositories are now looked up. (Before, refreshVersions would search all dependencies in all repositories of all modules and their buildscript, regardless of which module was declaring them.) Dependency constants in Ktor no longer uses the native suffixed artifacts (because Kotlin 1.4 drops them, as the main ones become multiplatform) Fixes \u00b6 Version sorting would crash if a version had a long number in it. This has now been fixed, any length of digit sequence is now supported in versions. Fix maven coordinates of several dependency constants Don\u2019t crash on repositories that are not https or file or have non password credentials. The AndroidX.test.ext.jankTestHelper constant and few other ones in Firebase.mlKit had wrong maven coordinates. This has been fixed, and tests have been added to prevent it from happening again on any dependency constant we provide. Previous releases \u00b6 Change log","title":"Change Log"},{"location":"CHANGELOG/#change-log-for-refreshversions","text":"","title":"Change log for refreshVersions"},{"location":"CHANGELOG/#unreleased","text":"TK (Also, screw GitHub Actions, their workflow_dispatch doesn\u2019t work.)","title":"Unreleased"},{"location":"CHANGELOG/#version-097-2020-10-16","text":"","title":"Version 0.9.7 (2020-10-16)"},{"location":"CHANGELOG/#fixes","text":"Running the refreshVersions task twice or more would fail with \u201cexecutor rejected\u201d as an error message, until the Gradle daemon is killed. This has now been fixed. (Issue #263) The refreshVersions task was failing after the latest Gradle release candidate was superseded by the stable release because the API would return an empty JSON object after this, which we didn\u2019t expect. (Minor) We fixed a typo in a diagnostic task name ( refreshVersionsDependenciesMapping )","title":"Fixes"},{"location":"CHANGELOG/#version-096-2020-10-12","text":"","title":"Version 0.9.6 (2020-10-12)"},{"location":"CHANGELOG/#fixes_1","text":"This release fixes a major memory leak that would make Gradle Daemons unusable after several builds (or Gradle syncs/imports). We are very sorry for that issue, and the annoyance it might have caused. We experienced it too as users, and that\u2019s why we are bringing the fix now. We took the necessary measures to avoid future recurrence of such memory leaks. Fix of a bug that\u2019d make the first Gradle sync after adding a dependency fail.","title":"Fixes"},{"location":"CHANGELOG/#breaking-change","text":"If you were using Jetpack Compose, the compiler dependency had its maven coordinates changed in version 1.0.0-alpha04. We updated the AndroidX.compose.compiler dependency constant, which means it now works only for Compose 1.0.0-alpha04 and more future versions.","title":"Breaking change"},{"location":"CHANGELOG/#new-dependency-constants","text":"Google.android.playServices.mlKit Google.mlKit KotlinX.serialization.json","title":"New dependency constants"},{"location":"CHANGELOG/#deprecated","text":"Firebase ML Kit has been rebranded to Google ML Kit along with API and feature changes since 2020-08-14 update , so we deprecated the Firebase.mlKit dependencies and introduced new ones in Google.android.playServices.mlKit and Google.mlKit .","title":"Deprecated"},{"location":"CHANGELOG/#new-features","text":"refreshVersions will now warn you when Gradle is not up to date, and will give you the commands to run to update it for you to copy/paste and run. It works if you\u2019re using a release candidate, and also if you\u2019re using a nightly version!","title":"New features"},{"location":"CHANGELOG/#version-095-2020-08-21","text":"This is a major release that brings surface-level and internal changes, paving the way for the upcoming 1.0 release. The plugin setup/bootstrap has changed , so check out the updated documentation in Setup .","title":"Version 0.9.5 (2020-08-21)"},{"location":"CHANGELOG/#new-features_1","text":"Self update discovery. RefreshVersions will check for its own updates , and add available comments in the settings.gradle[.kts] file if needed for easy upgrade. This allows you to get future improvements conveniently. Support for buildscript dependencies. It now works just like regular dependencies. First class support for buildSrc Support maven repositories with basic authentication (aka. credentials with username and password) Going forward, refreshVersions will be able to auto-migrate any breaking changes a new version would introduce in your versions.properties , build.gradle and build.gradle.kts files in. This version of refreshVersions integrates the facility to let future versions of refreshVersions that migration is needed, and from which version. This is a very important change that ensures you can keep your projects updated with the least effort possible.","title":"New features"},{"location":"CHANGELOG/#new-dependency-constants_1","text":"Kotlin.stdlib (for the base version of the stdlib) KotlinX: html Coroutines: reactive reactor rx2 rx3 Serialization: core (replaces runtime artifacts since 1.0.0-RC) protobuf cbor properties io reflect.lite nodeJs COIL , a **Co**routine **I**mage **L**oader for Android. Square: LeakCanary KotlinPoet Wire SqlDelight Moshi Picasso okio Retrofit2: Adapter: java8 (renamed from retrofitJava8) rxJava1 (renamed from retrofitRxJava1) rxJava2 (renamed from retrofitRxJava2) rxJava3 KoTest (in the Testing object) CashApp: sqlDelight (alias to Square.sqlDelight) turbine Copper Google: Dagger (including hilt for Android) Android: browserHelper JakeWharton: picnic wormholeGradlePlugin confundusGradlePlugin moshi.shimo AndroidX: Gaming Hilt startup tracing vectorDrawableSeekable Window Core: animation animationTesting Security: cryptoKtx identityCredential Compose: Runtime: dispatch savedInstance liveData rxJava2 Animation Ui Foundation Material Media2: lifecycle Concurrent: futuresKtx","title":"New dependency constants"},{"location":"CHANGELOG/#dependency-constants-renamed","text":"Several dependencies constants have been renamed in this release (compared to version 0.9.4). If you were using one of the following, you\u2019ll need to migrate these usages. We recommend to use \u201cReplace in Path\u201d in IntelliJ or Android Studio, filtering for the *.gradle.kts or *.gradle file extensions to do these replacements with ease. Note that for future versions, refreshVersions will be able to do this automatically. Here\u2019s the list of renamed dependency constants: AndroidX.coreKtx -> AndroidX.core.ktx AndroidX.coreRole -> AndroidX.core.role Square.retrofit2.adapter.retrofitJava8 -> Square.retrofit2.adapter.java8 Square.retrofit2.adapter.retrofitRxJava1 -> Square.retrofit2.adapter.rxJava1 Square.retrofit2.adapter.retrofitRxJava2 -> Square.retrofit2.adapter.rxJava2 Testing.junit.junitJupiter -> Testing.junit Testing.mockK.mockK -> Testing.mockK","title":"Dependency constants renamed"},{"location":"CHANGELOG/#changes","text":"Make the refreshVersions task cancellable during network requests. Now, only http 404 and 401 responses from repositories will be silent. Server errors (i.e. all but http 404 and 401 responses) are now reported. Network failures are now reported. There is now a connection timeout (10 seconds per request for now) An error is reported if a dependency wasn\u2019t found in any of the configured repositories. All the searched repositories are now listed if a dependency wasn\u2019t found in any of them. Only declared repositories are now looked up. (Before, refreshVersions would search all dependencies in all repositories of all modules and their buildscript, regardless of which module was declaring them.) Dependency constants in Ktor no longer uses the native suffixed artifacts (because Kotlin 1.4 drops them, as the main ones become multiplatform)","title":"Changes"},{"location":"CHANGELOG/#fixes_2","text":"Version sorting would crash if a version had a long number in it. This has now been fixed, any length of digit sequence is now supported in versions. Fix maven coordinates of several dependency constants Don\u2019t crash on repositories that are not https or file or have non password credentials. The AndroidX.test.ext.jankTestHelper constant and few other ones in Firebase.mlKit had wrong maven coordinates. This has been fixed, and tests have been added to prevent it from happening again on any dependency constant we provide.","title":"Fixes"},{"location":"CHANGELOG/#previous-releases","text":"Change log","title":"Previous releases"},{"location":"add-dependencies/","text":"Add dependencies \u00b6 Use built-in dependency notations \u00b6 refreshVersions provides read-to-use organized dependency notations for select popular libraries of the following ecosystems: Kotlin Multiplatform Kotlin/JVM Android That doesn\u2019t prevent you from using refreshVersions in a Gradle project that is not using Kotlin or is not an Android project. You can use them in any build.gradle or build.gradle.kts file. Here\u2019s an example of how it looks like in the IDE: No imports needed. Autocomplete in IDE for easy discoverability. You can see all the dependency objects in this directory . Wait, what version are those dependencies using? \u00b6 All these dependency notations specify their version as the version placeholder ( _ ), so refreshVersions can replace them seamlessly with the corresponding value defined in the versions.properties file, via Gradle APIs. After adding a dependency that doesn\u2019t have its version specified in the versions.properties file yet, refreshVersions will edit it and put the most stable recent version in it on the next Gradle sync (or any other Gradle run). It will also put any less stable versions as comments, allowing you to quickly upgrade if needed. Add Gradle plugins \u00b6 This section doesn\u2019t apply to plugins that are configured in a buildscript block (since these have their versions configured like regular dependencies), but only to those that are configured solely with a plugin id. To add such a plugin, do as usual, but do not specify the version in the build.gradle or build.gradle.kts file. Instead, set it up like so in the versions.properties file: versions.properties plugin.com.apollographql.apollo = 2.4.1 plugin.com.squareup.sqldelight = 1.4.3 Then you can omit the plugin version in all build.gradle(.kts) of your project: some-module/build.gradle.kts plugins { id ( \"com.squareup.sqldelight\" ) id ( \"com.apollographql.apollo\" ) } some-module/build.gradle plugins { id 'com.squareup.sqldelight' id 'com.apollographql.apollo' } As you see, the convention is pretty simple. The key is the id of the plugin, prefixed by plugin. : plugin.some.plugin.id sets the version of the plugin of id some.plugin.id . Non-built-in dependency notations \u00b6 Use gradle buildSrcVersions (WIP) \u00b6 Yet another approach to managing dependencies is to use the Gradle buildSrc module, and to automatically generate a file Libs.kt that contains all the dependencies applied to your build: buildSrc/src/main/kotlin/Libs.kt /** * Generated by `$ ./gradlew buildSrcVersions` */ object Libs { const val guava : String = \"com.google.guava:guava:_\" const val guice : String = \"com.google.inject:guice:_\" } Because this file used the placeholder version _ , it is compatible with gradle refreshVersions! This feature is not done yet. If you think we should prioritze it, please vote for this issue with a \ud83d\udc4d and subscribe to it. Use Package Search from JetBrains \u00b6 JetBrains offers the plugin Package Search . Package Search provides a nice UX to add a dependency: Can you use it with refreshVersions? Sure, just use the version placeholder ( _ ). Use the libraries.gradle pattern \u00b6 An older approach to centralize dependencies is to have a libraries.gradle file: libraries.gradle ext . libraries = [ // Groovy map literal spring_core: \"org.springframework:spring-core:3.1\" , junit: \"junit:junit:4.10\" ] some-module/build.gradle apply ( from = \"../libraries.gradle\" ) dependencies { compile libraries . spring_core testCompile libraries . junit } Does that work with refreshVersions too? Yes, just use the version placeholder ( _ ): libraries.gradle ext.libraries = [ // Groovy map literal - spring_core: \"org.springframework:spring-core:3.1\", + spring_core: \"org.springframework:spring-core:_\", - junit: \"junit:junit:4.10\" + junit: \"junit:junit:_\" ]","title":"Add Dependencies"},{"location":"add-dependencies/#add-dependencies","text":"","title":"Add dependencies"},{"location":"add-dependencies/#use-built-in-dependency-notations","text":"refreshVersions provides read-to-use organized dependency notations for select popular libraries of the following ecosystems: Kotlin Multiplatform Kotlin/JVM Android That doesn\u2019t prevent you from using refreshVersions in a Gradle project that is not using Kotlin or is not an Android project. You can use them in any build.gradle or build.gradle.kts file. Here\u2019s an example of how it looks like in the IDE: No imports needed. Autocomplete in IDE for easy discoverability. You can see all the dependency objects in this directory .","title":"Use built-in dependency notations"},{"location":"add-dependencies/#wait-what-version-are-those-dependencies-using","text":"All these dependency notations specify their version as the version placeholder ( _ ), so refreshVersions can replace them seamlessly with the corresponding value defined in the versions.properties file, via Gradle APIs. After adding a dependency that doesn\u2019t have its version specified in the versions.properties file yet, refreshVersions will edit it and put the most stable recent version in it on the next Gradle sync (or any other Gradle run). It will also put any less stable versions as comments, allowing you to quickly upgrade if needed.","title":"Wait, what version are those dependencies using?"},{"location":"add-dependencies/#add-gradle-plugins","text":"This section doesn\u2019t apply to plugins that are configured in a buildscript block (since these have their versions configured like regular dependencies), but only to those that are configured solely with a plugin id. To add such a plugin, do as usual, but do not specify the version in the build.gradle or build.gradle.kts file. Instead, set it up like so in the versions.properties file: versions.properties plugin.com.apollographql.apollo = 2.4.1 plugin.com.squareup.sqldelight = 1.4.3 Then you can omit the plugin version in all build.gradle(.kts) of your project: some-module/build.gradle.kts plugins { id ( \"com.squareup.sqldelight\" ) id ( \"com.apollographql.apollo\" ) } some-module/build.gradle plugins { id 'com.squareup.sqldelight' id 'com.apollographql.apollo' } As you see, the convention is pretty simple. The key is the id of the plugin, prefixed by plugin. : plugin.some.plugin.id sets the version of the plugin of id some.plugin.id .","title":"Add Gradle plugins"},{"location":"add-dependencies/#non-built-in-dependency-notations","text":"","title":"Non-built-in dependency notations"},{"location":"add-dependencies/#use-gradle-buildsrcversions-wip","text":"Yet another approach to managing dependencies is to use the Gradle buildSrc module, and to automatically generate a file Libs.kt that contains all the dependencies applied to your build: buildSrc/src/main/kotlin/Libs.kt /** * Generated by `$ ./gradlew buildSrcVersions` */ object Libs { const val guava : String = \"com.google.guava:guava:_\" const val guice : String = \"com.google.inject:guice:_\" } Because this file used the placeholder version _ , it is compatible with gradle refreshVersions! This feature is not done yet. If you think we should prioritze it, please vote for this issue with a \ud83d\udc4d and subscribe to it.","title":"Use gradle buildSrcVersions (WIP)"},{"location":"add-dependencies/#use-package-search-from-jetbrains","text":"JetBrains offers the plugin Package Search . Package Search provides a nice UX to add a dependency: Can you use it with refreshVersions? Sure, just use the version placeholder ( _ ).","title":"Use Package Search from JetBrains"},{"location":"add-dependencies/#use-the-librariesgradle-pattern","text":"An older approach to centralize dependencies is to have a libraries.gradle file: libraries.gradle ext . libraries = [ // Groovy map literal spring_core: \"org.springframework:spring-core:3.1\" , junit: \"junit:junit:4.10\" ] some-module/build.gradle apply ( from = \"../libraries.gradle\" ) dependencies { compile libraries . spring_core testCompile libraries . junit } Does that work with refreshVersions too? Yes, just use the version placeholder ( _ ): libraries.gradle ext.libraries = [ // Groovy map literal - spring_core: \"org.springframework:spring-core:3.1\", + spring_core: \"org.springframework:spring-core:_\", - junit: \"junit:junit:4.10\" + junit: \"junit:junit:_\" ]","title":"Use the libraries.gradle pattern"},{"location":"faq/","text":"FAQ \u00b6 TK","title":"FAQ"},{"location":"faq/#faq","text":"TK","title":"FAQ"},{"location":"gradle-buildsrcversions/","text":"The buildSrc module \u00b6 The buildSrc is a Gradle module where you can write Kotlin code like usual (with full tooling support). That code is then be available to all your build files - not your final application. One cool thing you can do with it is to replace those libraries.gradle files we used to write: buildSrc/src/main/kotlin/Libs.kt object Libs { const val okhttp = \"com.squareup.okhttp3:okhttp:\" + Versions . okhttp const val okio = \"com.squareup.okio:okio:\" + Versions . okio } buildSrc/src/main/kotlin/Versions.kt object Versions { const val okhttp = \"3.12.1\" const val okio = \"2.0.0\" } The crucial difference was that IntelliJ IDEA and Android Studio have good support for calling it from build.gradle[.kts] Finally the IDE tooling we deserve: auto-completion jumping to definition \u2026 \u201cgradle buildSrcVersions\u201d is dead\u2026 \u00b6 The ancestor of the plugin refreshVersions was a plugin called buildSrcVersions . What it did was to auto-generate the buildSrc/.../{Libs,Versions}.kt files above! $ ./gradlew buildSrcVersions > Task :dependencyUpdates > Task :buildSrcVersions new file: buildSrc/build.gradle.kts new file: buildSrc/.gitignore new file: buildSrc/src/main/kotlin/Libs.kt new file: buildSrc/src/main/kotlin/Versions.kt .. long live \u201cgradle buildSrcLibs\u201d! \u00b6 The Versions.kt file was replaced by a technically better solution, the versions.properties file. But the Libs.kt file has still pretty good use cases, like a project with lots of Gradle modules written in Groovy. That\u2019s why the plugin refreshVersions still contains a task :buildSrcVersions \u2013 which is just an alias for the better named task :buildSrcLibs . Use it like this: $ ./gradlew buildSrcLibs > Task :buildSrcLibs new file: versions.properties new file: buildSrc/src/main/kotlin/Libs.kt The task generates what you expect: versions.properties version.okhttp = 3.12.1 version.okio = 2.0.0 buildSrc/src/main/kotlin/Libs.kt object Libs { const val okhttp = \"com.squareup.okhttp3:okhttp:_\" const val okio = \"com.squareup.okio:okio:_\" } The constant generated in Libs.kt are the same as they was in the plugin buildSrcVersions . This makes updating to refreshVersions pretty straightforward. Replace your dependencies \u00b6 Sync your Gradle build. You can now start to replace your magic strings with the properties available in Libs.kt Update dependencies \u00b6 You can still automatically look for updates, but this is now done with the task :refreshVersions and editing the file versions.properties $ gradle refreshVersions Read more: Update dependencies .","title":"Gradle buildsrcversions"},{"location":"gradle-buildsrcversions/#the-buildsrc-module","text":"The buildSrc is a Gradle module where you can write Kotlin code like usual (with full tooling support). That code is then be available to all your build files - not your final application. One cool thing you can do with it is to replace those libraries.gradle files we used to write: buildSrc/src/main/kotlin/Libs.kt object Libs { const val okhttp = \"com.squareup.okhttp3:okhttp:\" + Versions . okhttp const val okio = \"com.squareup.okio:okio:\" + Versions . okio } buildSrc/src/main/kotlin/Versions.kt object Versions { const val okhttp = \"3.12.1\" const val okio = \"2.0.0\" } The crucial difference was that IntelliJ IDEA and Android Studio have good support for calling it from build.gradle[.kts] Finally the IDE tooling we deserve: auto-completion jumping to definition \u2026","title":"The buildSrc module"},{"location":"gradle-buildsrcversions/#gradle-buildsrcversions-is-dead","text":"The ancestor of the plugin refreshVersions was a plugin called buildSrcVersions . What it did was to auto-generate the buildSrc/.../{Libs,Versions}.kt files above! $ ./gradlew buildSrcVersions > Task :dependencyUpdates > Task :buildSrcVersions new file: buildSrc/build.gradle.kts new file: buildSrc/.gitignore new file: buildSrc/src/main/kotlin/Libs.kt new file: buildSrc/src/main/kotlin/Versions.kt","title":"\"gradle buildSrcVersions\" is dead..."},{"location":"gradle-buildsrcversions/#long-live-gradle-buildsrclibs","text":"The Versions.kt file was replaced by a technically better solution, the versions.properties file. But the Libs.kt file has still pretty good use cases, like a project with lots of Gradle modules written in Groovy. That\u2019s why the plugin refreshVersions still contains a task :buildSrcVersions \u2013 which is just an alias for the better named task :buildSrcLibs . Use it like this: $ ./gradlew buildSrcLibs > Task :buildSrcLibs new file: versions.properties new file: buildSrc/src/main/kotlin/Libs.kt The task generates what you expect: versions.properties version.okhttp = 3.12.1 version.okio = 2.0.0 buildSrc/src/main/kotlin/Libs.kt object Libs { const val okhttp = \"com.squareup.okhttp3:okhttp:_\" const val okio = \"com.squareup.okio:okio:_\" } The constant generated in Libs.kt are the same as they was in the plugin buildSrcVersions . This makes updating to refreshVersions pretty straightforward.","title":".. long live \"gradle buildSrcLibs\"!"},{"location":"gradle-buildsrcversions/#replace-your-dependencies","text":"Sync your Gradle build. You can now start to replace your magic strings with the properties available in Libs.kt","title":"Replace your dependencies"},{"location":"gradle-buildsrcversions/#update-dependencies","text":"You can still automatically look for updates, but this is now done with the task :refreshVersions and editing the file versions.properties $ gradle refreshVersions Read more: Update dependencies .","title":"Update dependencies"},{"location":"migration/","text":"Migration \u00b6 You can migrate existing dependencies, so they use the version placeholder in order to have their available updates found by refreshVersions and easily applied. We provide an experimental interactive Gradle task made for migration. To use it, run the following command and follow the instructions : ./gradlew migrateToRefreshVersionsDependenciesConstants --console = plain About the experimental status \u00b6 That migration task is safe to use (except if you have different modules with different versions of the same dependency family), but its UX has a few known issues. Here\u2019s the improvement plan: Ergonomics (Don\u2019t require to type a full word to validate migration of a single dependency) Keep track of what has been migrated already to not show out of sync hardcoded dependencies count Automatically replace dependency notations in the build files when possible safely Have better rules to ignore dependencies added by plugins (e.g. \u201ckotlin-android-extensions\u201d plugin) Its name (remove lengthy migrateToRefreshVersionsDependenciesConstants and have a --migrate flag to refreshVersions redirect to it instead) These improvements are planned for the 1.0 release. You can follow this issue to track when it is resolved exactly, and you can also vote for it with a \ud83d\udc4d.","title":"Migration"},{"location":"migration/#migration","text":"You can migrate existing dependencies, so they use the version placeholder in order to have their available updates found by refreshVersions and easily applied. We provide an experimental interactive Gradle task made for migration. To use it, run the following command and follow the instructions : ./gradlew migrateToRefreshVersionsDependenciesConstants --console = plain","title":"Migration"},{"location":"migration/#about-the-experimental-status","text":"That migration task is safe to use (except if you have different modules with different versions of the same dependency family), but its UX has a few known issues. Here\u2019s the improvement plan: Ergonomics (Don\u2019t require to type a full word to validate migration of a single dependency) Keep track of what has been migrated already to not show out of sync hardcoded dependencies count Automatically replace dependency notations in the build files when possible safely Have better rules to ignore dependencies added by plugins (e.g. \u201ckotlin-android-extensions\u201d plugin) Its name (remove lengthy migrateToRefreshVersionsDependenciesConstants and have a --migrate flag to refreshVersions redirect to it instead) These improvements are planned for the 1.0 release. You can follow this issue to track when it is resolved exactly, and you can also vote for it with a \ud83d\udc4d.","title":"About the experimental status"},{"location":"setup/","text":"Setup \u00b6 This guide will help you set up refreshVersions in a Gradle project. Update Gradle (if needed) \u00b6 Only Gradle 6.3+ is supported at the moment, because there were a lot of changes in dependencies management in Gradle 6, and other compatibility concerns. It also allows for a simpler setup for plugins for example. Updating Gradle is anyway usually a good idea. You get fewer bugs, more features, and faster builds. Run this command to update: ./gradlew wrapper --gradle-version 6 .7 You should also try to update the Gradle plugins present in your build to the latest version. For example on an Android project, do update the version of the Gradle Android Plugin. The Gradle documentation has detailed migration guide if you are stuck: From Gradle 6+: https://docs.gradle.org/current/userguide/upgrading_version_6.html From Gradle 5.x: https://docs.gradle.org/current/userguide/upgrading_version_5.html From Gradle 4.x: https://docs.gradle.org/current/userguide/upgrading_version_4.html About Gradle\u2019s Settings file \u00b6 For refreshVersions to be able to work for all the dependencies in your project, including for the ones in the buildscript \u2018s classpath , it needs to be setup in the Gradle settings. A Gradle project has a Settings file called settings.gradle or settings.gradle.kts where you must respect a certain order (otherwise, the build breaks). The order is: 1. imports, if any. 2. The pluginManagement block, if any. 3. The buildscript block, if any. (We will use it) 4. The plugins block, if any settings plugins are applied. 5. Logic for Gradle settings (any other code). See the example snippet below: import com.example.something // Imports at the top, as usual. pluginManagement {} // Optional buildscript { // We will setup refreshVersions here, see below. } plugins {} // Optional // Then you can have other code after the blocks above, // we will bootstrap refreshVersions here. rootProject . name = \"My Project\" // Optional, defaults to parent dir's name. include ( \":app\" ) // If the project has modules/subprojects to declare. Bootstrap refreshVersions \u00b6 Here is how to configure gradle refreshVersions: settings.gradle.kts import de.fayard.refreshVersions.bootstrapRefreshVersions buildscript { repositories { gradlePluginPortal () } dependencies . classpath ( \"de.fayard.refreshVersions:refreshVersions:0.9.7\" ) } bootstrapRefreshVersions () settings.gradle import de.fayard.refreshVersions.RefreshVersionsSetup buildscript { repositories { gradlePluginPortal () } dependencies . classpath ( \"de.fayard.refreshVersions:refreshVersions:0.9.7\" ) } RefreshVersionsSetup . bootstrap ( settings ) If you upgrade from the plugin buildSrcVersions \u00b6 Before refreshVersions, there was the plugin buildSrcVersions If your project is using it, remove all its configuration from the top build.gradle[.kts] file build.gradle.kts -plugins { - id(\"de.fayard.buildSrcVersions\") version \"0.3.2\" -} -buildSrcVersions { - someOption = \"somevalue\" -} The task buildSrcVersions is still available. Read more: gradle buildSrcVersions . If you have a buildSrc module \u00b6 If you use the buildSrc module and have dependencies declared in the buildSrc/build.gradle[.kts] file, you probably want to use refreshVersions there as well. For that, an extra special setup is required. buildSrc/settings.gradle.kts import de.fayard.refreshVersions.bootstrapRefreshVersionsForBuildSrc buildscript { repositories { gradlePluginPortal () } dependencies . classpath ( \"de.fayard.refreshVersions:refreshVersions:0.9.7\" ) } bootstrapRefreshVersionsForBuildSrc () buildSrc/settings.gradle import de.fayard.refreshVersions.RefreshVersionsSetup buildscript { repositories { gradlePluginPortal () } dependencies . classpath ( \"de.fayard.refreshVersions:refreshVersions:0.9.7\" ) } RefreshVersionsSetup . bootstrapForBuildSrc ( settings ) If you have a composite/included build \u00b6 Sharing used versions with included builds is not supported at the moment. If you need/want this feature, please vote with a \ud83d\udc4d on this issue , subscribe to it, and tell us about your use case, to help us prioritize. If you want to use a development version \u00b6 To use a development version (for example to test an unreleased new feature), you need to find the published development versions by searching in the recent commits on the develop branch (they start with \u201cDev version\u201d). You also need to add the maven repository https://dl.bintray.com/jmfayard/maven as shown below: settings.gradle.kts import de.fayard.refreshVersions.bootstrapRefreshVersions buildscript { repositories { gradlePluginPortal () maven ( \"https://dl.bintray.com/jmfayard/maven\" ) } dependencies . classpath ( \"de.fayard.refreshVersions:refreshVersions:0.9.7-dev-001\" ) } bootstrapRefreshVersions () settings.gradle import de.fayard.refreshVersions.RefreshVersionsSetup buildscript { repositories { gradlePluginPortal () maven { url 'https://dl.bintray.com/jmfayard/maven' } } dependencies . classpath ( \"de.fayard.refreshVersions:refreshVersions:0.9.7-dev-001\" ) } RefreshVersionsSetup . bootstrap ( settings ) Next steps \u00b6 You did it! refreshVersions is now properly setup. Now, you might want to: Migrate/opt-in existing dependency declarations , so the refreshVersions task can find available updates for you. Add new dependencies . Update dependencies .","title":"Setup"},{"location":"setup/#setup","text":"This guide will help you set up refreshVersions in a Gradle project.","title":"Setup"},{"location":"setup/#update-gradle-if-needed","text":"Only Gradle 6.3+ is supported at the moment, because there were a lot of changes in dependencies management in Gradle 6, and other compatibility concerns. It also allows for a simpler setup for plugins for example. Updating Gradle is anyway usually a good idea. You get fewer bugs, more features, and faster builds. Run this command to update: ./gradlew wrapper --gradle-version 6 .7 You should also try to update the Gradle plugins present in your build to the latest version. For example on an Android project, do update the version of the Gradle Android Plugin. The Gradle documentation has detailed migration guide if you are stuck: From Gradle 6+: https://docs.gradle.org/current/userguide/upgrading_version_6.html From Gradle 5.x: https://docs.gradle.org/current/userguide/upgrading_version_5.html From Gradle 4.x: https://docs.gradle.org/current/userguide/upgrading_version_4.html","title":"Update Gradle (if needed)"},{"location":"setup/#about-gradles-settings-file","text":"For refreshVersions to be able to work for all the dependencies in your project, including for the ones in the buildscript \u2018s classpath , it needs to be setup in the Gradle settings. A Gradle project has a Settings file called settings.gradle or settings.gradle.kts where you must respect a certain order (otherwise, the build breaks). The order is: 1. imports, if any. 2. The pluginManagement block, if any. 3. The buildscript block, if any. (We will use it) 4. The plugins block, if any settings plugins are applied. 5. Logic for Gradle settings (any other code). See the example snippet below: import com.example.something // Imports at the top, as usual. pluginManagement {} // Optional buildscript { // We will setup refreshVersions here, see below. } plugins {} // Optional // Then you can have other code after the blocks above, // we will bootstrap refreshVersions here. rootProject . name = \"My Project\" // Optional, defaults to parent dir's name. include ( \":app\" ) // If the project has modules/subprojects to declare.","title":"About Gradle's Settings file"},{"location":"setup/#bootstrap-refreshversions","text":"Here is how to configure gradle refreshVersions: settings.gradle.kts import de.fayard.refreshVersions.bootstrapRefreshVersions buildscript { repositories { gradlePluginPortal () } dependencies . classpath ( \"de.fayard.refreshVersions:refreshVersions:0.9.7\" ) } bootstrapRefreshVersions () settings.gradle import de.fayard.refreshVersions.RefreshVersionsSetup buildscript { repositories { gradlePluginPortal () } dependencies . classpath ( \"de.fayard.refreshVersions:refreshVersions:0.9.7\" ) } RefreshVersionsSetup . bootstrap ( settings )","title":"Bootstrap refreshVersions"},{"location":"setup/#if-you-upgrade-from-the-plugin-buildsrcversions","text":"Before refreshVersions, there was the plugin buildSrcVersions If your project is using it, remove all its configuration from the top build.gradle[.kts] file build.gradle.kts -plugins { - id(\"de.fayard.buildSrcVersions\") version \"0.3.2\" -} -buildSrcVersions { - someOption = \"somevalue\" -} The task buildSrcVersions is still available. Read more: gradle buildSrcVersions .","title":"If you upgrade from the plugin buildSrcVersions"},{"location":"setup/#if-you-have-a-buildsrc-module","text":"If you use the buildSrc module and have dependencies declared in the buildSrc/build.gradle[.kts] file, you probably want to use refreshVersions there as well. For that, an extra special setup is required. buildSrc/settings.gradle.kts import de.fayard.refreshVersions.bootstrapRefreshVersionsForBuildSrc buildscript { repositories { gradlePluginPortal () } dependencies . classpath ( \"de.fayard.refreshVersions:refreshVersions:0.9.7\" ) } bootstrapRefreshVersionsForBuildSrc () buildSrc/settings.gradle import de.fayard.refreshVersions.RefreshVersionsSetup buildscript { repositories { gradlePluginPortal () } dependencies . classpath ( \"de.fayard.refreshVersions:refreshVersions:0.9.7\" ) } RefreshVersionsSetup . bootstrapForBuildSrc ( settings )","title":"If you have a buildSrc module"},{"location":"setup/#if-you-have-a-compositeincluded-build","text":"Sharing used versions with included builds is not supported at the moment. If you need/want this feature, please vote with a \ud83d\udc4d on this issue , subscribe to it, and tell us about your use case, to help us prioritize.","title":"If you have a composite/included build"},{"location":"setup/#if-you-want-to-use-a-development-version","text":"To use a development version (for example to test an unreleased new feature), you need to find the published development versions by searching in the recent commits on the develop branch (they start with \u201cDev version\u201d). You also need to add the maven repository https://dl.bintray.com/jmfayard/maven as shown below: settings.gradle.kts import de.fayard.refreshVersions.bootstrapRefreshVersions buildscript { repositories { gradlePluginPortal () maven ( \"https://dl.bintray.com/jmfayard/maven\" ) } dependencies . classpath ( \"de.fayard.refreshVersions:refreshVersions:0.9.7-dev-001\" ) } bootstrapRefreshVersions () settings.gradle import de.fayard.refreshVersions.RefreshVersionsSetup buildscript { repositories { gradlePluginPortal () maven { url 'https://dl.bintray.com/jmfayard/maven' } } dependencies . classpath ( \"de.fayard.refreshVersions:refreshVersions:0.9.7-dev-001\" ) } RefreshVersionsSetup . bootstrap ( settings )","title":"If you want to use a development version"},{"location":"setup/#next-steps","text":"You did it! refreshVersions is now properly setup. Now, you might want to: Migrate/opt-in existing dependency declarations , so the refreshVersions task can find available updates for you. Add new dependencies . Update dependencies .","title":"Next steps"},{"location":"update-dependencies/","text":"Update dependencies \u00b6 The core feature is gradle refreshVersions is that it will lookup automatically for available updates for all the dependencies that it manages. This is done in three small steps: 1. Run the refreshVersions Gradle task \u00b6 Run the refreshVersions gradle task on the root project: ./gradlew refreshVersions Hint: You don\u2019t need to leave the IDE to run a Gradle task. IntelliJ has a handy action named \u201cExecute Gradle Task\u201d: Gradle refreshVersions is fast: it usually takes less than 10 seconds to execute on relatively big projects. 2. Apply the updates you want to \u00b6 Open the versions.properties file. Let say you have this initial state: After you have run the refreshVersions task, you will see the available updates as comments : Why as comments? \u00b6 Looking for available updates is certainly a job best done by a computer program (instead of you doing the monkey job of googling, clicking and scrolling for every single used dependency). However, the decision of whether to upgrade or not, when, and towards which version, is best decided by the developers responsible like you. Edit the versions.properties file \u00b6 If you decide to update, just replace the previous version with the update: If you decide to not update for now, you can leave the comments there. They will not affect your build, and will serve as a reminder to revisit upgrading these dependencies later. They also allow you to glance at how behind the dependencies are, which is a way to estimate the technical debt of the project regarding the dependencies upgrades. If you want to delete these comments, it\u2019s possible too, and it\u2019s safe. Running the refreshVersions task will bring them back (plus any newer available update). 3. Perform a Gradle sync/reload \u00b6 The file versions.properties is part of the Gradle build. Consequently, after you have edited it, you need to ensure the IDE gets the changes. The action to do it have a different name depending on the IDE: IntelliJ IDEA: Run the \u201cReload all Gradle projects\u201d action (via ctrl / cmd + shift + A ), or click the refresh arrows in the Gradle tool window Android Studio: Run the \u201cSync Project with Gradle Files\u201d action (via ctrl / cmd + shift + A ), or click the elephant + arrow icon in the toolbar. At that point, you probably want to: \u23ed Migrate deprecated symbols (if any) \ud83d\udd28 Ensure the codebase still builds properly \u2705 Ensure the tests still run properly \ud83d\udd75\ufe0f\u200d\u2640\ufe0f Do manual testing if needed \u2705 Commit when appropriate \ud83d\udc9d Become our sponsor to thank us for the time saved \ud83d\ude09","title":"Update Dependencies"},{"location":"update-dependencies/#update-dependencies","text":"The core feature is gradle refreshVersions is that it will lookup automatically for available updates for all the dependencies that it manages. This is done in three small steps:","title":"Update dependencies"},{"location":"update-dependencies/#1-run-the-refreshversions-gradle-task","text":"Run the refreshVersions gradle task on the root project: ./gradlew refreshVersions Hint: You don\u2019t need to leave the IDE to run a Gradle task. IntelliJ has a handy action named \u201cExecute Gradle Task\u201d: Gradle refreshVersions is fast: it usually takes less than 10 seconds to execute on relatively big projects.","title":"1. Run the refreshVersions Gradle task"},{"location":"update-dependencies/#2-apply-the-updates-you-want-to","text":"Open the versions.properties file. Let say you have this initial state: After you have run the refreshVersions task, you will see the available updates as comments :","title":"2. Apply the updates you want to"},{"location":"update-dependencies/#why-as-comments","text":"Looking for available updates is certainly a job best done by a computer program (instead of you doing the monkey job of googling, clicking and scrolling for every single used dependency). However, the decision of whether to upgrade or not, when, and towards which version, is best decided by the developers responsible like you.","title":"Why as comments?"},{"location":"update-dependencies/#edit-the-versionsproperties-file","text":"If you decide to update, just replace the previous version with the update: If you decide to not update for now, you can leave the comments there. They will not affect your build, and will serve as a reminder to revisit upgrading these dependencies later. They also allow you to glance at how behind the dependencies are, which is a way to estimate the technical debt of the project regarding the dependencies upgrades. If you want to delete these comments, it\u2019s possible too, and it\u2019s safe. Running the refreshVersions task will bring them back (plus any newer available update).","title":"Edit the versions.properties file"},{"location":"update-dependencies/#3-perform-a-gradle-syncreload","text":"The file versions.properties is part of the Gradle build. Consequently, after you have edited it, you need to ensure the IDE gets the changes. The action to do it have a different name depending on the IDE: IntelliJ IDEA: Run the \u201cReload all Gradle projects\u201d action (via ctrl / cmd + shift + A ), or click the refresh arrows in the Gradle tool window Android Studio: Run the \u201cSync Project with Gradle Files\u201d action (via ctrl / cmd + shift + A ), or click the elephant + arrow icon in the toolbar. At that point, you probably want to: \u23ed Migrate deprecated symbols (if any) \ud83d\udd28 Ensure the codebase still builds properly \u2705 Ensure the tests still run properly \ud83d\udd75\ufe0f\u200d\u2640\ufe0f Do manual testing if needed \u2705 Commit when appropriate \ud83d\udc9d Become our sponsor to thank us for the time saved \ud83d\ude09","title":"3. Perform a Gradle sync/reload"},{"location":"contributing/before-you-contribute/","text":"Before you contribute \u00b6 Please, in order to not waste your efforts, your time, and our time, before working on any contribution, take a little time to read the relevant parts of the contributing guide. Code of Conduct \u00b6 First, we have a very simple code of conduct that you need to follow while interacting on this repo: Whenever you are about to post or commit, ask yourself \u201cWould an idiot do that?\u201d, and if they would, do not do that thing. https://youtu.be/KFwUcEwD4l4 Use this Code of Conduct as you like in your own projects and organizations. Q & A \u00b6 Q: What about breathing? A: The behavior must be exclusive to idiocy. General considerations \u00b6 Note: If you only want to improve the docs, you can skip the rest of this page and jump right on the documentation specific contributing guide . Reliability \u00b6 refreshVersions is used by a lot of different projects, and it shall be as reliable as possible, especially since it takes part in the build process of these projects and could break it in case of a bug. As a consequence, we strive to keep its quality as high as we can, and we actively avoid regressions and unreliable code. Sometimes, that might mean not adding a feature because of its impact, or the risks for end projects. Please, when submitting a feature request or a contribution, take some time to think about the implications on projects other than yours. Compatibility \u00b6 Also, refreshVersions being a long term project, we do our best to not break the builds of our users on upgrade, so for any new feature or change, we shall have way to introduce it in a compatible way. Note that as a Gradle plugin, we have the ability to automate migration tasks if needed, but it cannot always apply. Submitting issues \u00b6 If you want to report an issue or submit a feature request, see this guide to help us address it as quickly as possible. Submitting PRs \u00b6 Unless it\u2019s the special case of minor documentation improvement, please, do not start working on a PR before you\u2019re assigned via the corresponding issue. Not doing so might lead to overlapping efforts, and it\u2019s less likely we would accept it. If you have been assigned an issue, if you are a maintainer of this project or if you just want to play with the project on your own, first, see how to set up the dev environment properly , as the IDE will not get it right on its own. Once you\u2019ve ensured this is set up correctly, you\u2019ll need to follow our development process . It has the information you need to make a successful contribution, regardless of the type of change.","title":"Before you contribute"},{"location":"contributing/before-you-contribute/#before-you-contribute","text":"Please, in order to not waste your efforts, your time, and our time, before working on any contribution, take a little time to read the relevant parts of the contributing guide.","title":"Before you contribute"},{"location":"contributing/before-you-contribute/#code-of-conduct","text":"First, we have a very simple code of conduct that you need to follow while interacting on this repo: Whenever you are about to post or commit, ask yourself \u201cWould an idiot do that?\u201d, and if they would, do not do that thing. https://youtu.be/KFwUcEwD4l4 Use this Code of Conduct as you like in your own projects and organizations.","title":"Code of Conduct"},{"location":"contributing/before-you-contribute/#q-a","text":"Q: What about breathing? A: The behavior must be exclusive to idiocy.","title":"Q &amp; A"},{"location":"contributing/before-you-contribute/#general-considerations","text":"Note: If you only want to improve the docs, you can skip the rest of this page and jump right on the documentation specific contributing guide .","title":"General considerations"},{"location":"contributing/before-you-contribute/#reliability","text":"refreshVersions is used by a lot of different projects, and it shall be as reliable as possible, especially since it takes part in the build process of these projects and could break it in case of a bug. As a consequence, we strive to keep its quality as high as we can, and we actively avoid regressions and unreliable code. Sometimes, that might mean not adding a feature because of its impact, or the risks for end projects. Please, when submitting a feature request or a contribution, take some time to think about the implications on projects other than yours.","title":"Reliability"},{"location":"contributing/before-you-contribute/#compatibility","text":"Also, refreshVersions being a long term project, we do our best to not break the builds of our users on upgrade, so for any new feature or change, we shall have way to introduce it in a compatible way. Note that as a Gradle plugin, we have the ability to automate migration tasks if needed, but it cannot always apply.","title":"Compatibility"},{"location":"contributing/before-you-contribute/#submitting-issues","text":"If you want to report an issue or submit a feature request, see this guide to help us address it as quickly as possible.","title":"Submitting issues"},{"location":"contributing/before-you-contribute/#submitting-prs","text":"Unless it\u2019s the special case of minor documentation improvement, please, do not start working on a PR before you\u2019re assigned via the corresponding issue. Not doing so might lead to overlapping efforts, and it\u2019s less likely we would accept it. If you have been assigned an issue, if you are a maintainer of this project or if you just want to play with the project on your own, first, see how to set up the dev environment properly , as the IDE will not get it right on its own. Once you\u2019ve ensured this is set up correctly, you\u2019ll need to follow our development process . It has the information you need to make a successful contribution, regardless of the type of change.","title":"Submitting PRs"},{"location":"contributing/improving-docs/","text":"Improving docs \u00b6 Docs are powered by MKDocs \u00b6 The documentation of refreshVersions is published on a website accessible via this url: https://jmfayard.github.io/refreshVersions . It is generated with MKDocs from Markdown files. The variant of Markdown used in MKDocs has useful additional features that we use: - \u201cVariables\u201d interpolation, useful for long urls repeated in the doc. - Automatic generation of table of contents based on headings. Where is the doc source \u00b6 A bunch of things are defined in the mkdocs.yml file (located at the root of the repo): The structure of the documentation website is under the nav key. Under the extra key, we have common text snippets (example usage: {{link.site}} ) Website metadata is defined at the top of the file (you probably don\u2019t need to touch it) Theme and MKDocs configuration The content of the documentation itself is in the docs directory where you can find Markdown files and images in the img directory. Edit the doc \u00b6 Before starting any work, create a branch in your fork that is based on the release branch . Please, avoid non-improvements such as adding typos, or spelling errors. Also, try to keep the language simple, non-ambiguous, and explicit enough, so all of our users can understand it. \ud83d\ude4f View your changes \u00b6 Run one of the following commands, to ensure you have the tools to build the website locally: pip3 install -r docs/requirements.txt pip install -r docs/requirements.txt Note: on Linux and macOS, pip3 is most likely already installed. On Windows, you might want to install anaconda/Python to get it. Start the local server using the mkdocs serve command. You\u2019ll quickly see a link appear in the console to view it in your default browser. Any saved changes will refresh the page automatically if the right one is open in the browser. Once you\u2019re done, you can close the tab, and quit the local server ( ctrl + C ). Submit your changes \u00b6 Once you\u2019re done, please commit your changes with a clear title and message that mentions what changed in simple terms, then submit the pull request on GitHub.","title":"Improving docs"},{"location":"contributing/improving-docs/#improving-docs","text":"","title":"Improving docs"},{"location":"contributing/improving-docs/#docs-are-powered-by-mkdocs","text":"The documentation of refreshVersions is published on a website accessible via this url: https://jmfayard.github.io/refreshVersions . It is generated with MKDocs from Markdown files. The variant of Markdown used in MKDocs has useful additional features that we use: - \u201cVariables\u201d interpolation, useful for long urls repeated in the doc. - Automatic generation of table of contents based on headings.","title":"Docs are powered by MKDocs"},{"location":"contributing/improving-docs/#where-is-the-doc-source","text":"A bunch of things are defined in the mkdocs.yml file (located at the root of the repo): The structure of the documentation website is under the nav key. Under the extra key, we have common text snippets (example usage: {{link.site}} ) Website metadata is defined at the top of the file (you probably don\u2019t need to touch it) Theme and MKDocs configuration The content of the documentation itself is in the docs directory where you can find Markdown files and images in the img directory.","title":"Where is the doc source"},{"location":"contributing/improving-docs/#edit-the-doc","text":"Before starting any work, create a branch in your fork that is based on the release branch . Please, avoid non-improvements such as adding typos, or spelling errors. Also, try to keep the language simple, non-ambiguous, and explicit enough, so all of our users can understand it. \ud83d\ude4f","title":"Edit the doc"},{"location":"contributing/improving-docs/#view-your-changes","text":"Run one of the following commands, to ensure you have the tools to build the website locally: pip3 install -r docs/requirements.txt pip install -r docs/requirements.txt Note: on Linux and macOS, pip3 is most likely already installed. On Windows, you might want to install anaconda/Python to get it. Start the local server using the mkdocs serve command. You\u2019ll quickly see a link appear in the console to view it in your default browser. Any saved changes will refresh the page automatically if the right one is open in the browser. Once you\u2019re done, you can close the tab, and quit the local server ( ctrl + C ).","title":"View your changes"},{"location":"contributing/improving-docs/#submit-your-changes","text":"Once you\u2019re done, please commit your changes with a clear title and message that mentions what changed in simple terms, then submit the pull request on GitHub.","title":"Submit your changes"},{"location":"contributing/submitting-issues/","text":"Submitting issues \u00b6 Check for existing issues first \u00b6 Be it a bug report or a feature request, someone else might have already submitted it, so, please, start by searching for existing issues. If you find an existing one, please vote for it with the thumbs up emoji (\ud83d\udc4d). Also, if you find that some info is missing for us, and you can provide it, do it as it might help to resolve it faster. You can also influence the priorities if the impact on your project is high by telling us in the comments, but please avoid useless comments like \u201c+1\u201d, and make sure you stay constructive . Bug reports \u00b6 Please, before writing a report, make sure the bug has not been fixed in the latest version of refreshVersions. In your report, provide the needed details to reproduce the issue, and not more than that. However, if the doesn\u2019t reproduce consistently, please report it anyway, and give as many details as you can for us to investigate. If you know any workarounds, please mention them. Finally, make sure you stay constructive in your report. Feature requests \u00b6 When submitting a feature request, please explain why you need the feature, what is your use case , and any context that might help understand it. These are more important that your solution suggestion, even if ideas are always welcome. If there\u2019s an alternative to what you want, please show what it is.","title":"Submitting issues"},{"location":"contributing/submitting-issues/#submitting-issues","text":"","title":"Submitting issues"},{"location":"contributing/submitting-issues/#check-for-existing-issues-first","text":"Be it a bug report or a feature request, someone else might have already submitted it, so, please, start by searching for existing issues. If you find an existing one, please vote for it with the thumbs up emoji (\ud83d\udc4d). Also, if you find that some info is missing for us, and you can provide it, do it as it might help to resolve it faster. You can also influence the priorities if the impact on your project is high by telling us in the comments, but please avoid useless comments like \u201c+1\u201d, and make sure you stay constructive .","title":"Check for existing issues first"},{"location":"contributing/submitting-issues/#bug-reports","text":"Please, before writing a report, make sure the bug has not been fixed in the latest version of refreshVersions. In your report, provide the needed details to reproduce the issue, and not more than that. However, if the doesn\u2019t reproduce consistently, please report it anyway, and give as many details as you can for us to investigate. If you know any workarounds, please mention them. Finally, make sure you stay constructive in your report.","title":"Bug reports"},{"location":"contributing/submitting-issues/#feature-requests","text":"When submitting a feature request, please explain why you need the feature, what is your use case , and any context that might help understand it. These are more important that your solution suggestion, even if ideas are always welcome. If there\u2019s an alternative to what you want, please show what it is.","title":"Feature requests"},{"location":"contributing/submitting-prs/dependency-notations-updates/","text":"Submitting dependency notations updates \u00b6 Thanks for considering an update to the built-in dependency notations in refreshVersions! However, we are in the process of refactoring the way we define dependency notations in refreshVersions, so it\u2019s less overhead for both you and us, and less error-prone to do overall (especially regarding backwards and forward compatibility). That means that we\u2019re unlikely to accept any submission of dependency notation updates for now . To be informed when that refactoring is complete, you can subscribe to this issue: https://github.com/jmfayard/refreshVersions/issues/275","title":"Dependency notations"},{"location":"contributing/submitting-prs/dependency-notations-updates/#submitting-dependency-notations-updates","text":"Thanks for considering an update to the built-in dependency notations in refreshVersions! However, we are in the process of refactoring the way we define dependency notations in refreshVersions, so it\u2019s less overhead for both you and us, and less error-prone to do overall (especially regarding backwards and forward compatibility). That means that we\u2019re unlikely to accept any submission of dependency notation updates for now . To be informed when that refactoring is complete, you can subscribe to this issue: https://github.com/jmfayard/refreshVersions/issues/275","title":"Submitting dependency notations updates"},{"location":"contributing/submitting-prs/dev-env/","text":"Dev environment for contributors \u00b6 Setting up the project in your IDE \u00b6 Get the right IDE \u00b6 We recommend using the most recent version of IntelliJ IDEA to contribute to this project (consider 2020.3 or newer). Prepare your fork \u00b6 Fork this project from GitHub if not already done. Clone your fork locally. Checkout the develop branch. If your fork is not fresh, ensure its develop branch is up to date with upstream: Run the git fetch upstream command. Run the git merge upstream/develop command. Create a new branch based on develop with a name describing what it is about. Import the \u201cplugins\u201d Gradle project \u00b6 Locate the plugins/settings.gradle.kts file in the \u201cProject\u201d tool window. Right-click on it to open the contextual menu. Select \u201cImport Gradle Project\u201d. Publish the current version locally \u00b6 This step is required for the samples to work afterwards and enable you to test your changes. Ensure the version in the plugins/version.txt file ends with -LOCAL-SNAPSHOT to avoid overlapping a published version. In the \u201cGradle\u201d tool window, or from the terminal, run the publishToMavenLocal task. Testing changes locally \u00b6 Import the samples to test the changes \u00b6 We have multiple samples to test integration in different scenarios. Here are their names, you can find them in so-named directories in the repo: sample-kotlin sample-groovy sample-android sample-multi-modules The first two samples (sample-kotlin and sample-groovy) are the ones you should always test your changes on. They are lightweight, so it\u2019s quick to set up and iterate with. For edge cases in multi-modules projects and for Android specific things, the two other samples are the ones to test your changes on. To import a sample, just like you did for the plugins Gradle project, right-click on the settings.gradle or settings.gradle.kts file and select the \u201cImport Gradle Project\u201d option. Testing in your own project \u00b6 To test your changes in your own project locally, in the settings.gradle or settings.gradle.kts file, you need to add the mavenLocal() repository in the pluginManagement section (create the block at the top of the file if you don\u2019t already have one): pluginManagement { repositories { gradlePluginPortal () // Needed to keep using the Gradle plugin portal for other plugins. mavenLocal () // Also use mavenLocal for local-only versions. } } Once you\u2019re done, you can replace the version with the local snapshot version (e.g. 0.9.8 -> 0.9.9-LOCAL-SNAPSHOT ) and test your changes.","title":"Dev environment"},{"location":"contributing/submitting-prs/dev-env/#dev-environment-for-contributors","text":"","title":"Dev environment for contributors"},{"location":"contributing/submitting-prs/dev-env/#setting-up-the-project-in-your-ide","text":"","title":"Setting up the project in your IDE"},{"location":"contributing/submitting-prs/dev-env/#get-the-right-ide","text":"We recommend using the most recent version of IntelliJ IDEA to contribute to this project (consider 2020.3 or newer).","title":"Get the right IDE"},{"location":"contributing/submitting-prs/dev-env/#prepare-your-fork","text":"Fork this project from GitHub if not already done. Clone your fork locally. Checkout the develop branch. If your fork is not fresh, ensure its develop branch is up to date with upstream: Run the git fetch upstream command. Run the git merge upstream/develop command. Create a new branch based on develop with a name describing what it is about.","title":"Prepare your fork"},{"location":"contributing/submitting-prs/dev-env/#import-the-plugins-gradle-project","text":"Locate the plugins/settings.gradle.kts file in the \u201cProject\u201d tool window. Right-click on it to open the contextual menu. Select \u201cImport Gradle Project\u201d.","title":"Import the \"plugins\" Gradle project"},{"location":"contributing/submitting-prs/dev-env/#publish-the-current-version-locally","text":"This step is required for the samples to work afterwards and enable you to test your changes. Ensure the version in the plugins/version.txt file ends with -LOCAL-SNAPSHOT to avoid overlapping a published version. In the \u201cGradle\u201d tool window, or from the terminal, run the publishToMavenLocal task.","title":"Publish the current version locally"},{"location":"contributing/submitting-prs/dev-env/#testing-changes-locally","text":"","title":"Testing changes locally"},{"location":"contributing/submitting-prs/dev-env/#import-the-samples-to-test-the-changes","text":"We have multiple samples to test integration in different scenarios. Here are their names, you can find them in so-named directories in the repo: sample-kotlin sample-groovy sample-android sample-multi-modules The first two samples (sample-kotlin and sample-groovy) are the ones you should always test your changes on. They are lightweight, so it\u2019s quick to set up and iterate with. For edge cases in multi-modules projects and for Android specific things, the two other samples are the ones to test your changes on. To import a sample, just like you did for the plugins Gradle project, right-click on the settings.gradle or settings.gradle.kts file and select the \u201cImport Gradle Project\u201d option.","title":"Import the samples to test the changes"},{"location":"contributing/submitting-prs/dev-env/#testing-in-your-own-project","text":"To test your changes in your own project locally, in the settings.gradle or settings.gradle.kts file, you need to add the mavenLocal() repository in the pluginManagement section (create the block at the top of the file if you don\u2019t already have one): pluginManagement { repositories { gradlePluginPortal () // Needed to keep using the Gradle plugin portal for other plugins. mavenLocal () // Also use mavenLocal for local-only versions. } } Once you\u2019re done, you can replace the version with the local snapshot version (e.g. 0.9.8 -> 0.9.9-LOCAL-SNAPSHOT ) and test your changes.","title":"Testing in your own project"},{"location":"contributing/submitting-prs/dev-process/","text":"Development process \u00b6 Note: If the contribution you want to make is updating, adding or removing dependency notations, you can skip the rest of this document and go directly to the specific guide . Better safe than sorry \u00b6 Fixing bugs \u00b6 Please, make sure your bug fix doesn\u2019t introduce new bugs before submitting. Changing behavior of existing features \u00b6 Behavior changes might introduce bugs, and these might not be caught until users face them. Consequently, whenever possible, we keep the old implementation and add the new one side by side, with a feature flag controlling which one is being used. That allows our users to switch-off changes that might interfere with their project setup. For changes that break the API or setup of some or all projects, we provide automatic or semi-automatic migration on upgrade. If it\u2019s needed, we will let you know in the corresponding issue. New features \u00b6 Unless impossible, we add every new feature behind a feature-flag, so our users can disable it if it causes any problem in their project. Send a draft early \u00b6 We do not want you to spend a lot of time on a change only to realize it didn\u2019t do in the right direction for us to be able to integrate it in the project. Consequently, we are asking you, especially for new features, to send us an early draft PR that we can give early feedback on before you complete your contribution. Check nothing is broken \u00b6 Before committing anything, please check nothing is broken. \ud83d\ude4f Ways to do it are running the check task against the plugins project, as well as ensuring the sample projects still build, and behave properly in the IDE with your changes. Use proper commit messages \u00b6 If you don\u2019t, we will squash your PR into one commit on merge. You can reach for help \u00b6 Feel free to ask for any help in the PR comments or in the corresponding issue. Submitting the PR \u00b6 In the text of the PR, make sure to reference the corresponding issue properly. Examples: \u00b6 For bug fixes: Fixes #456 For new features or changes: Resolves #123","title":"Development process"},{"location":"contributing/submitting-prs/dev-process/#development-process","text":"Note: If the contribution you want to make is updating, adding or removing dependency notations, you can skip the rest of this document and go directly to the specific guide .","title":"Development process"},{"location":"contributing/submitting-prs/dev-process/#better-safe-than-sorry","text":"","title":"Better safe than sorry"},{"location":"contributing/submitting-prs/dev-process/#fixing-bugs","text":"Please, make sure your bug fix doesn\u2019t introduce new bugs before submitting.","title":"Fixing bugs"},{"location":"contributing/submitting-prs/dev-process/#changing-behavior-of-existing-features","text":"Behavior changes might introduce bugs, and these might not be caught until users face them. Consequently, whenever possible, we keep the old implementation and add the new one side by side, with a feature flag controlling which one is being used. That allows our users to switch-off changes that might interfere with their project setup. For changes that break the API or setup of some or all projects, we provide automatic or semi-automatic migration on upgrade. If it\u2019s needed, we will let you know in the corresponding issue.","title":"Changing behavior of existing features"},{"location":"contributing/submitting-prs/dev-process/#new-features","text":"Unless impossible, we add every new feature behind a feature-flag, so our users can disable it if it causes any problem in their project.","title":"New features"},{"location":"contributing/submitting-prs/dev-process/#send-a-draft-early","text":"We do not want you to spend a lot of time on a change only to realize it didn\u2019t do in the right direction for us to be able to integrate it in the project. Consequently, we are asking you, especially for new features, to send us an early draft PR that we can give early feedback on before you complete your contribution.","title":"Send a draft early"},{"location":"contributing/submitting-prs/dev-process/#check-nothing-is-broken","text":"Before committing anything, please check nothing is broken. \ud83d\ude4f Ways to do it are running the check task against the plugins project, as well as ensuring the sample projects still build, and behave properly in the IDE with your changes.","title":"Check nothing is broken"},{"location":"contributing/submitting-prs/dev-process/#use-proper-commit-messages","text":"If you don\u2019t, we will squash your PR into one commit on merge.","title":"Use proper commit messages"},{"location":"contributing/submitting-prs/dev-process/#you-can-reach-for-help","text":"Feel free to ask for any help in the PR comments or in the corresponding issue.","title":"You can reach for help"},{"location":"contributing/submitting-prs/dev-process/#submitting-the-pr","text":"In the text of the PR, make sure to reference the corresponding issue properly.","title":"Submitting the PR"},{"location":"contributing/submitting-prs/dev-process/#examples","text":"For bug fixes: Fixes #456 For new features or changes: Resolves #123","title":"Examples:"}]}